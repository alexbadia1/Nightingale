/**
 * lexer.ts
 * Author: Alex Badia
 * 
 * This is the Lexing stage of compilation.
 */

// TODO: Document Well
// TODO: Implement a full Stack Trace
// TODO: Implement a verbose mode for lexer
// TODO: Implement a debug mode for lexer
// TODO: Implement reading multiple programs at once
// TODO: Add warnings such as missing EOP ($), if number of open braces don't match closed braces
// TODO: Issue Errors: such as invalid tokens and an *extra quotation mark*.


module NightingaleCompiler {
    export class Lexer {
        constructor(
            /**
             * An array of Lexical Tokens.
             * 
             * An array that must be filled with Lexical 
             * Tokens and passed to the Parser in synchronous manner.
             * 
             * TODO: Implement as a Stream where tokens are emitted into the Stream 
             *       and have the Parser subscribe to it and listen for changes in state.
             */
            public tokenStream: Array<LexicalToken> = [],

            /**
             * An array of Substrings and Lexical Tokens.
             * 
             * An array that must be filled with substrings and Lexical 
             * Tokens and passed to the Parser in synchronous manner.
             */
            public stacktraceStack: Array<any> = [],

            /**
             * Stores tokens generated by each recurrence of the substring loop.
             * 
             * If null, no tokens were found in the current substring. 
             * If non-null, stores the longest matched token found in the substring.
             */
            private tempToken: NightingaleCompiler.LexicalToken = null,

            /**
             * Current location in source code.
             * 
             * Implemented as zero based, but reported to user as 1 based.
             */
            private lineNumber: number = 0,
            private linePosition: number = 0,

            // Detects if current position is in a string
            private isInString: boolean = false,
            private startStringExpressionLine: number = 0,
            private startStringExpressionPosition: number = 0,

            // Detects if current position is in a string
            private isInComment: boolean = false,
            private startCommentLine: number = -1,
            private startCommentLinePosition: number = -1,
            private endCommentLine: number = -1,
            private endCommentLinePosition: number = -1,
        ) { }

        /**
         * Scans source code and generates tokens.
         * 
        * @param {string} sourceCode formatted source code from CodeMirror input field.
         */
        public main(sourceCode: string) {
            /**
             * Pool of predefined tokens and their definitions
             * 
             * Rule Order:
             *  1. Keyword
             *  2. ID
             *  3. Symbol, Digit, Character
             */
            // Generate the token pool
            var tokenPool = [

                /**
                 * 1. Keywords
                 * 
                 * Consist of commands and types.
                 */

                // Commands
                new NightingaleCompiler.LexicalToken(KEYWORD_PRINT, /^(print)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_WHILE, /^(while)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_IF, /^(if)$/, null, -1, -1),

                // Types
                new NightingaleCompiler.LexicalToken(KEYWORD_INT, /^(int)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_STRING, /^(string)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_BOOLEAN, /^(boolean)$/, null, -1, -1),

                // Boolean keywords
                new NightingaleCompiler.LexicalToken(KEYWORD_TRUE, /^(true)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_FALSE, /^(false)$/, null, -1, -1),

                /**
                 * 2. Identifiers
                 * 
                 * Can be character of id depending if inside a string or not.
                 */
                new NightingaleCompiler.LexicalToken(IDENTIFIER, /^[a-z]$/, null, -1, -1),

                /**
                 * 3. Symbols
                 */

                // Comments
                new NightingaleCompiler.LexicalToken(START_BLOCK_COMMENT, /^(\/\*)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(END_BLOCK_COMMENT, /^(\*\/)$/, null, -1, -1),

                // Quotation
                new NightingaleCompiler.LexicalToken(STRING_EXPRESSION_BOUNDARY, /^["]$/, null, -1, -1),

                // Open/Close blocks
                new NightingaleCompiler.LexicalToken(SYMBOL_OPEN_BLOCK, /^[\{]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_CLOSE_BLOCK, /^[\}]$/, null, -1, -1),

                // Open/Close arguments
                new NightingaleCompiler.LexicalToken(SYMBOL_OPEN_ARGUMENT, /^[\(]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_CLOSE_ARGUMENT, /^[\)]$/, null, -1, -1),

                // Operands
                new NightingaleCompiler.LexicalToken(SYMBOL_INT_OP, /^[\+]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_BOOL_OP_EQUALS, /^(==)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_BOOL_OP_NOT_EQUALS, /^(!=)$/, null, -1, -1),

                // Assignments
                new NightingaleCompiler.LexicalToken(SYMBOL_ASSIGNMENT_OP, /^[=]$/, null, -1, -1),

                // Digits
                new NightingaleCompiler.LexicalToken(DIGIT, /^[0-9]$/, null, -1, -1),

                // Whitespace
                new NightingaleCompiler.LexicalToken(SPACE_SINGLE, new RegExp("^ $"), null, -1, -1),
                new NightingaleCompiler.LexicalToken(SPACE_TAB, new RegExp("^\t$"), null, -1, -1),
                new NightingaleCompiler.LexicalToken(SPACE_END_OF_LINE, new RegExp("^\n$"), null, -1, -1),

                // End of Program
                new NightingaleCompiler.LexicalToken(END_OF_PROGRAM, /^[\$]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(CHARACTER, /^[a-z]$/, null, -1, -1),
            ];


            let lastPosition: number = 0;
            let currentPosition: number = 1;
            LoopThroughSourceCodeWhileLoop: while (lastPosition <= sourceCode.length && currentPosition <= sourceCode.length) {
                // console.log(`Current position: ${currentPosition}`);

                // Don't forget that the end part in substring is not inclusive!
                let currentChunk: string = sourceCode.substring(lastPosition, currentPosition);


                this.stacktraceStack.push(sourceCode.substring(lastPosition, currentPosition));
                console.log("Current Chunk: " + sourceCode.substring(lastPosition, currentPosition));

                // Already inside a comment
                if (this.isInComment) {

                    // Don't care about contents of a comment until an end comment symbol is found.
                    if (/(\*\/$)/.test(currentChunk)) {

                        // Generate token
                        this.tempToken = new NightingaleCompiler.LexicalToken(END_BLOCK_COMMENT, /^(\*\/)$/, currentChunk, this.lineNumber, currentPosition - 1);

                        // Emit close comment token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);

                        // Record end position
                        this.isInComment = false;
                        this.endCommentLine = this.lineNumber;
                        this.endCommentLinePosition = currentPosition;

                        // Move the starting position after the string value that created the token.
                        lastPosition = currentPosition + 1;

                        // Reset the current position back to the new starting position
                        currentPosition = lastPosition + 1;
                    }// if

                    // Keeping reading through comment
                    else {
                        currentPosition++;
                    }// else
                }// if

                // In string
                else if (this.isInString) {

                    // Must be a CHARACTER_TOKEN.
                    if (/^[a-z]$/.test(currentChunk) || /^[\s]$/.test(currentChunk)) {

                        // Generate token
                        this.tempToken = new NightingaleCompiler.LexicalToken(CHARACTER, /^(\*\/)$/, currentChunk, this.lineNumber, currentPosition);

                        // Emit close comment token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);

                        // Record end position
                        this.isInComment = false;
                        this.endCommentLine = this.lineNumber;
                        this.endCommentLinePosition = currentPosition;

                        // Move the starting position after the string value that created the token.
                        lastPosition = currentPosition;

                        // Reset the current position back to the new starting position
                        currentPosition = lastPosition + 1;
                    }// if: must be a CHARACTER_TOKEN

                    // Quotation found in comment
                    else if (/^["]$/.test(currentChunk)) {
                        this.isInString = false;

                        // Generate an invalid token for the first character in the invalid sub string.
                        let endStringExpressionToken = new LexicalToken("END_STRING_EXPRESSION", null, currentChunk, this.lineNumber, lastPosition);

                        // Emit invalid token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${endStringExpressionToken.name}, Ancestor: ${endStringExpressionToken.ancestor}, Line-Position: ${endStringExpressionToken.linePosition}`);

                        // Move the starting position after the string value that created the token.
                        lastPosition = currentPosition;

                        // Reset the current position back to the new starting position
                        currentPosition = lastPosition + 1;
                    }// if

                    // Not a valid character
                    else {
                        // Generate an invalid token for the first character in the invalid sub string.
                        let invalidToken = new LexicalToken(INVALID_TOKEN, null, currentChunk, this.lineNumber, lastPosition);

                        // Emit invalid token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${invalidToken.name}, Ancestor: ${invalidToken.ancestor}, Line-Position: ${invalidToken.linePosition}`);

                        // Move last position up one line position
                        lastPosition++;
                        currentPosition = lastPosition + 1;
                    }// else
                }// else-if

                // Not in comment nor in a string
                else {
                    // Keeps track if the current substring matches a token definition from the token pool.
                    let matchFound: boolean = false;

                    // Symbols, whitespace (if present and outside of quotes) and the EOP 
                    // meta-symbol mean that we can stop moving ahead and see what we’ve got so far.
                    if (/=$|\{$|\}$|\($|\)$|\"$|\+$|\/\*$|\*\/$|\s$|\$$/.test(currentChunk) && currentChunk.length > 1) {

                        /*
                         * Tokens were found in the substring.
                         * 
                         * Temporary token is useful:
                         *      - If null, no tokens were found.
                         *      - If not null, stores the longest matched token.
                        */
                        if (this.tempToken != null) {
                            // Emit the longest matched token.
                            this.tokenStream.push(this.tempToken);
                            this.stacktraceStack.push(this.tempToken);
                            console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);

                            // Move the starting position after the string value that created the token.
                            lastPosition += this.tempToken.ancestor.length;

                            // Reset the current position back to the new starting position
                            currentPosition = lastPosition + 1;

                            // Reset temp token
                            this.tempToken = null;

                            // Skip the Check Tokens From Token Pool Loop
                            continue LoopThroughSourceCodeWhileLoop;
                        }// if

                        /*
                         * No tokens were found in the substring.
                         * 
                         * That means the entire substring is filled with invalid 
                         * tokens, except for the last character which must be a symbol.
                        */
                        else {
                            // Generate an invalid token for the first character in the invalid sub string.
                            let invalidToken = new LexicalToken(INVALID_TOKEN, null, currentChunk[0], this.lineNumber, lastPosition);

                            // Emit invalid token
                            this.tokenStream.push(invalidToken);
                            this.stacktraceStack.push(invalidToken);
                            console.log(`Stream-Token: ${invalidToken.name}, Ancestor: ${invalidToken.ancestor}, Line-Position: ${invalidToken.linePosition}`);

                            // Move last position up one line position
                            lastPosition++;
                            currentPosition = lastPosition + 1;

                            // Skip the Check Tokens From Token Pool Loop
                            continue LoopThroughSourceCodeWhileLoop;
                        }// else

                    }// if

                    // Test current substring of source code against tokens in the token pool
                    CheckTokensFromTokenPoolLoop: for (let indexOfToken: number = 0; indexOfToken < tokenPool.length; ++indexOfToken) {

                        let currentToken = tokenPool[indexOfToken];

                        // Test against specific token
                        /**
                         * Test against a token from token pool.
                         * 
                         * Some Special Cases:
                         *  1.) Qoute
                         *      - All characters in a quote are CHARACTER_TOKENS
                         *  2.) Keywords 
                         *      - true | false | while | if | print | int | boolean | string
                         *  3.) Overlapping Symbols
                         *      - BoolOpEquals (==) and Assignment OP (=) have overlaping sets, in this case =.
                         *  4.) Whitespace
                         *  5.) End of program
                         */
                        if (currentToken.definition.test(currentChunk)) {
                            matchFound = true;

                            // String expression boundary symbol found, could be start or end.
                            if (currentToken.name == STRING_EXPRESSION_BOUNDARY) {

                                // Start of string
                                if (!this.isInString) {

                                    this.isInString = true;

                                    // Keep track where the string started
                                    this.startStringExpressionLine = this.lineNumber;
                                    this.startStringExpressionPosition = this.linePosition;

                                    // Generate STRING_EXPRESSION_BOUNDARY token.
                                    this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition);

                                    // Emit 
                                    this.tokenStream.push(this.tempToken);
                                    this.stacktraceStack.push(this.tempToken);
                                    console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${currentPosition}`);
                                }// if

                                // End of string
                                else {
                                    this.isInString = false;
                                }// else

                                // Increase the current position, whether a match was found or not.
                                lastPosition = currentPosition;
                                currentPosition = lastPosition + 1;

                                continue LoopThroughSourceCodeWhileLoop;
                            }// if

                            // Symbol found
                            else if (currentToken.name.includes(SYMBOL)) {

                                /**
                                 * Keeps track if a longer symbol is found or not.
                                 * 
                                 * If a longer symbol is found, the starting position must be
                                 * moved after the longer symbol, instead of the shorted symbol.
                                 */
                                let longerSymbolFound: boolean = false;

                                /**
                                 * Save the current symbols token.
                                 * 
                                 * If a longer symbol is found by peeking ahead, this symbols token
                                 * will be replaced with a new token for the longer symbol that was found.
                                 */
                                this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition);

                                /**
                                 * Peek ahead one line-position.
                                 * 
                                 * Some symbols have overlapping sets, such as:
                                 *  - Assignment Operation (=) and Boolean Operation Equals (==).
                                 *  - Boolean Operation Not Equals (!=) and Boolean Operation Equals (==).
                                 * 
                                 * Therfore, we must peek ahead to check for the LONGEST symbol.
                                 * Since our current language's longest symbols are length 2, we only need to peek ahead one line-position.
                                 */
                                let peekPosition: number = currentPosition + 1;

                                // Only peek ahead if we do not fall off the string (or in some languages, wrap-around).
                                if (peekPosition <= sourceCode.length) {

                                    /**
                                     * Generate a new substring from peeking ahead a line-position.
                                     * 
                                     * The longer substring will be tested to see if it matches a longer token.
                                     * If so, replace the original symbol token, with the current longer symbol token.
                                     */
                                    let peekingChunk: string = sourceCode.substring(lastPosition, peekPosition);

                                    // Loop through pool of tokens to see if the longer substring matches any of definitions.
                                    CheckForLongerSymbolLoop: for (let index: number = 0; index < tokenPool.length; ++index) {

                                        // Longer symbol has a token match!
                                        if (tokenPool[index].definition.test(peekingChunk)) {

                                            // Notify through boolean that the starting 
                                            // position must be changed to after the new LONGER symbol.
                                            longerSymbolFound = true;

                                            // Replace the current symbol token with the new longer token.
                                            this.tempToken = tokenPool[index].copyWith(peekingChunk, this.lineNumber, peekPosition);

                                            /**
                                             * Break out of loop on first token match.
                                             * 
                                             * This enforces priority of tokens by the order they are listed in the pool.
                                             */
                                            break CheckForLongerSymbolLoop;
                                        }// if
                                    }// for
                                }// if

                                // Longer symbol found
                                if (longerSymbolFound) {

                                    // Mover last position after the longer symbol.
                                    lastPosition = peekPosition;

                                    // Reset the current position to new starting point.
                                    currentPosition = lastPosition + 1;
                                }// if

                                // No longer token found.
                                else {
                                    // Move the starting position after the string value that created the token.
                                    lastPosition += this.tempToken.ancestor.length;

                                    // Reset the current position back to the new starting position.
                                    currentPosition = lastPosition + 1;
                                }// else

                                // Emit token to stream.
                                this.tokenStream.push(this.tempToken);
                                this.stacktraceStack.push(this.tempToken);
                                console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);

                                continue LoopThroughSourceCodeWhileLoop;
                            }// else-if

                            // Special Case: End Of Program Meta Symbol
                            else if (currentToken.name.includes(END_OF_PROGRAM)) {

                                // Generate end of program token.
                                this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition);

                                // Emit final token
                                console.log(`EOP-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${currentPosition}`);

                                /**
                                 * Reset some variables in the lexer to allow for another program to be read.
                                 * 
                                 * Probably don't want to reset the line number or anything.
                                 * But make sure you are starting fresh enough for a new program...
                                 * 
                                 * Also make sure to update the last and current positions to start after the EOP ($) symbol
                                 */

                                lastPosition = currentPosition;
                                currentPosition = lastPosition + 1;
                                continue LoopThroughSourceCodeWhileLoop;
                            }// else-if

                            // Normal Case Token
                            else {
                                // Replace temporary token with the new longest token.
                                this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition - (currentChunk.length - 1));

                                /**
                                 * Intermediate Token shown in stacktrace.
                                 * 
                                 * This is the first possible token found.
                                 * Most likely will be overriden if a longer token match is found.
                                 */
                                // console.log(`StackTrace-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);

                                // Increase the current position, whether a match was found or not.
                                currentPosition++;

                                continue LoopThroughSourceCodeWhileLoop;
                            }// else
                        }// if 
                    }// for

                    /**
                     * Characters that are not matched are illegal.
                     * 
                     * Some tokens have sets that overlap with illegal characters.
                     *  - BOOLEAN NOT EQUALS OPERATION (!=) overlaps with illegal character (!).
                     *  - START BLOCK COMMENT (/ *) overlaps with illegal character (/).
                     *  - END BLOCK COMMENT (* /), overlaps with illegal character (*).
                     */
                    if (!matchFound) {
                        console.log("Match not found!");
                        /**
                         * Check for the 3 illegal characters: ! or / or *
                         * 
                         * Must peek ahead to see if those illegal characters 
                         * are followed by a character that would make them legal symbols.
                         * 
                         * For example: 
                         *      - ! is illegal, but if followed by an = symbol,
                         *        becomes a legal != Boolean Operation Not Equal.
                         *      - / is illegal, but if folowed by an *, becomes a legal Start Comment Symbol.
                         */
                        if (/(^!$|^\*$|^\/$)/.test(currentChunk)) {
                            // Infinite loop protection
                            let foundMatchByPeekingAheadOfInvalidString: boolean = false;

                            /**
                             * Peek ahead one position.
                             * 
                             * Only need to peek ahead one position since 
                             * SYMBOLS in our grammar are only a max length of 2.
                             */
                            let nextPosition: number = currentPosition + 1;
                            let peekingChunk: string = sourceCode.substring(lastPosition, nextPosition);

                            /**
                             * Validate the new substring against the pool of tokens.
                             * 
                             * For example: 
                             *  - 1.) Original illegal symbol was !.
                             *  - 2.) We peeked ahead another character so now our new substring is !=.
                             *  - 3.) NOW, we validate != against the token pool.
                             */
                            for (let index: number = 0; index < tokenPool.length; ++index) {

                                // New substring matches a token!
                                if (tokenPool[index].definition.test(peekingChunk)) {
                                    foundMatchByPeekingAheadOfInvalidString = true;

                                    // Generate a new token.
                                    this.tempToken = tokenPool[index].copyWith(peekingChunk, this.lineNumber, nextPosition);

                                    // Special Case: token match was a START_BLOCK_COMMENT
                                    if (this.tempToken.name == START_BLOCK_COMMENT) {
                                        this.isInComment = true;

                                        // Keep track of the location
                                        this.startCommentLine = this.lineNumber;
                                        this.startCommentLinePosition = currentPosition;
                                    }// if: START_BLOCK_COMMENT

                                    // Special Case: token match was END_BLOCK_COMMENT
                                    if (this.tempToken.name == END_BLOCK_COMMENT) {

                                        // End Block Comment Symbol found without a matching Start Block Comment Symbol.
                                        if (!this.isInComment) {
                                            // Throw error

                                            // Generate an invalid token for the first character in the invalid sub string.
                                            let invalidToken = new LexicalToken(INVALID_TOKEN, null, currentChunk, this.lineNumber, currentPosition);

                                            // Emit invalid token
                                            this.tokenStream.push(this.tempToken);
                                            this.stacktraceStack.push(this.tempToken);
                                            console.log(`Stream-Token: ${invalidToken.name}, Ancestor: ${invalidToken.ancestor}, Line-Position: ${invalidToken.linePosition}`);

                                            // Update position
                                            lastPosition = currentPosition;
                                            currentPosition = lastPosition + 1;

                                            this.tempToken = null;
                                            continue LoopThroughSourceCodeWhileLoop;
                                        }// if: mismatch error

                                        // End Block Comment Symbol has matching Start Block Comment Symbol.
                                        else {
                                            this.isInComment = false;

                                            // Keep track of the location
                                            this.endCommentLine = this.lineNumber;
                                            this.endCommentLinePosition = currentPosition;
                                        }// else: no error
                                    }// if: END_BLOCK_COMMENT

                                    // Emit Token
                                    this.tokenStream.push(this.tempToken);
                                    this.stacktraceStack.push(this.tempToken);
                                    console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);

                                    // Update position
                                    lastPosition = nextPosition;
                                    currentPosition = lastPosition + 1;
                                    continue LoopThroughSourceCodeWhileLoop;
                                }// if: token match
                            }// for: validate against token pool

                            if (!foundMatchByPeekingAheadOfInvalidString) {
                                currentPosition++;
                            }// if

                        }// if: illegal character is: ! or / or *

                        // Not a special illegal character.
                        else {
                            currentPosition++;
                        }// else: not an illegal: ! or / or *

                    }// if: no token match found
                }// else: not in comment nor in string
            }// while: loop through source code
        }// function: main
    }// class: lexer
}// module: NightingaleCompiler

//  /=$|\{$|\}$|\($|\)$|\!$|\"$|\+$|\/\*$|\\*\/$|\s$/