/**
 * lexer.ts
 * Author: Alex Badia
 *
 * This is the Lexing stage of compilation.
 */
// TODO: Document Well
// TODO: Implement a full Stack Trace
// TODO: Implement a verbose mode for lexer
// TODO: Implement a debug mode for lexer
// TODO: Implement reading multiple programs at once
// TODO: Add warnings such as missing EOP ($)
var NightingaleCompiler;
(function (NightingaleCompiler) {
    class Lexer {
        constructor(
        /**
         * An array of Lexical Tokens.
         *
         * An array that must be filled with Lexical
         * Tokens and passed to the Parser in synchronous manner.
         *
         * TODO: Implement as a Stream where tokens are emitted into the Stream
         *       and have the Parser subscribe to it and listen for changes in state.
         */
        tokenStream = [], 
        /**
         * An array of Substrings and Lexical Tokens.
         *
         * An array that must be filled with substrings and Lexical
         * Tokens and passed to the Parser in synchronous manner.
         */
        stacktraceStack = [], 
        /**
         * Stores tokens generated by each recurrence of the substring loop.
         *
         * If null, no tokens were found in the current substring.
         * If non-null, stores the longest matched token found in the substring.
         */
        tempToken = null, 
        /**
         * Current location in source code.
         *
         * Implemented as zero based, but reported to user as 1 based.
         */
        lineNumber = 0, linePosition = 0, 
        // Detects if current position is in a string
        isInString = false, startStringExpressionLine = 0, startStringExpressionPosition = 0, 
        // Detects if current position is in a string
        isInComment = false, startCommentLine = -1, startCommentLinePosition = -1, endCommentLine = -1, endCommentLinePosition = -1) {
            this.tokenStream = tokenStream;
            this.stacktraceStack = stacktraceStack;
            this.tempToken = tempToken;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
            this.isInString = isInString;
            this.startStringExpressionLine = startStringExpressionLine;
            this.startStringExpressionPosition = startStringExpressionPosition;
            this.isInComment = isInComment;
            this.startCommentLine = startCommentLine;
            this.startCommentLinePosition = startCommentLinePosition;
            this.endCommentLine = endCommentLine;
            this.endCommentLinePosition = endCommentLinePosition;
        }
        /**
         * Scans source code and generates tokens.
         *
        * @param {string} sourceCode formatted source code from CodeMirror input field.
         */
        main(sourceCode) {
            /**
             * Pool of predefined tokens and their definitions
             *
             * Rule Order:
             *  1. Keyword
             *  2. ID
             *  3. Symbol, Digit, Character
             */
            // Generate the token pool
            var tokenPool = [
                /**
                 * 1. Keywords
                 *
                 * Consist of commands and types.
                 */
                // Commands
                new NightingaleCompiler.LexicalToken(KEYWORD_PRINT, /^(print)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_WHILE, /^(while)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_IF, /^(if)$/, null, -1, -1),
                // Types
                new NightingaleCompiler.LexicalToken(KEYWORD_INT, /^(int)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_STRING, /^(string)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_BOOLEAN, /^(boolean)$/, null, -1, -1),
                // Boolean keywords
                new NightingaleCompiler.LexicalToken(KEYWORD_TRUE, /^(true)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(KEYWORD_FALSE, /^(false)$/, null, -1, -1),
                /**
                 * 2. Identifiers
                 *
                 * Can be character of id depending if inside a string or not.
                 */
                new NightingaleCompiler.LexicalToken(IDENTIFIER, /^[a-z]$/, null, -1, -1),
                /**
                 * 3. Symbols
                 */
                // Comments
                new NightingaleCompiler.LexicalToken(START_BLOCK_COMMENT, /^(\/\*)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(END_BLOCK_COMMENT, /^(\*\/)$/, null, -1, -1),
                // Quotation
                new NightingaleCompiler.LexicalToken(STRING_EXPRESSION_BOUNDARY, /^["]$/, null, -1, -1),
                // Open/Close blocks
                new NightingaleCompiler.LexicalToken(SYMBOL_OPEN_BLOCK, /^[\{]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_CLOSE_BLOCK, /^[\}]$/, null, -1, -1),
                // Open/Close arguments
                new NightingaleCompiler.LexicalToken(SYMBOL_OPEN_ARGUMENT, /^[\(]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_CLOSE_ARGUMENT, /^[\)]$/, null, -1, -1),
                // Operands
                new NightingaleCompiler.LexicalToken(SYMBOL_INT_OP, /^[\+]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_BOOL_OP_EQUALS, /^(==)$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(SYMBOL_BOOL_OP_NOT_EQUALS, /^(!=)$/, null, -1, -1),
                // Assignments
                new NightingaleCompiler.LexicalToken(SYMBOL_ASSIGNMENT_OP, /^[=]$/, null, -1, -1),
                // Digits
                new NightingaleCompiler.LexicalToken(DIGIT, /^[0-9]$/, null, -1, -1),
                // Whitespace
                new NightingaleCompiler.LexicalToken(SPACE_SINGLE, new RegExp("^ $"), null, -1, -1),
                new NightingaleCompiler.LexicalToken(SPACE_TAB, new RegExp("^\t$"), null, -1, -1),
                new NightingaleCompiler.LexicalToken(SPACE_END_OF_LINE, new RegExp("^\n$"), null, -1, -1),
                // End of Program
                new NightingaleCompiler.LexicalToken(END_OF_PROGRAM, /^[\$]$/, null, -1, -1),
                new NightingaleCompiler.LexicalToken(CHARACTER, /^[a-z]$/, null, -1, -1),
            ];
            let lastPosition = 0;
            let currentPosition = 1;
            LoopThroughSourceCodeWhileLoop: while (lastPosition <= sourceCode.length && currentPosition <= sourceCode.length) {
                // console.log(`Current position: ${currentPosition}`);
                // Don't forget that the end part in substring is not inclusive!
                let currentChunk = sourceCode.substring(lastPosition, currentPosition);
                this.stacktraceStack.push(sourceCode.substring(lastPosition, currentPosition));
                console.log("Current Chunk: " + sourceCode.substring(lastPosition, currentPosition));
                // Already inside a comment
                if (this.isInComment) {
                    // Don't care about contents of a comment until an end comment symbol is found.
                    if (/(\*\/$)/.test(currentChunk)) {
                        // Generate token
                        this.tempToken = new NightingaleCompiler.LexicalToken(END_BLOCK_COMMENT, /^(\*\/)$/, currentChunk, this.lineNumber, currentPosition - 1);
                        // Emit close comment token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);
                        // Record end position
                        this.isInComment = false;
                        this.endCommentLine = this.lineNumber;
                        this.endCommentLinePosition = currentPosition;
                        // Move the starting position after the string value that created the token.
                        lastPosition = currentPosition + 1;
                        // Reset the current position back to the new starting position
                        currentPosition = lastPosition + 1;
                    } // if
                    // Keeping reading through comment
                    else {
                        currentPosition++;
                    } // else
                } // if
                // In string
                else if (this.isInString) {
                    // Must be a CHARACTER_TOKEN.
                    if (/^[a-z]$/.test(currentChunk) || /^[\s]$/.test(currentChunk)) {
                        // Generate token
                        this.tempToken = new NightingaleCompiler.LexicalToken(CHARACTER, /^(\*\/)$/, currentChunk, this.lineNumber, currentPosition);
                        // Emit close comment token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);
                        // Record end position
                        this.isInComment = false;
                        this.endCommentLine = this.lineNumber;
                        this.endCommentLinePosition = currentPosition;
                        // Move the starting position after the string value that created the token.
                        lastPosition = currentPosition;
                        // Reset the current position back to the new starting position
                        currentPosition = lastPosition + 1;
                    } // if: must be a CHARACTER_TOKEN
                    // Quotation found in comment
                    else if (/^["]$/.test(currentChunk)) {
                        this.isInString = false;
                        // Generate an invalid token for the first character in the invalid sub string.
                        let endStringExpressionToken = new NightingaleCompiler.LexicalToken("END_STRING_EXPRESSION", null, currentChunk, this.lineNumber, lastPosition);
                        // Emit invalid token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${endStringExpressionToken.name}, Ancestor: ${endStringExpressionToken.ancestor}, Line-Position: ${endStringExpressionToken.linePosition}`);
                        // Move the starting position after the string value that created the token.
                        lastPosition = currentPosition;
                        // Reset the current position back to the new starting position
                        currentPosition = lastPosition + 1;
                    } // if
                    // Not a valid character
                    else {
                        // Generate an invalid token for the first character in the invalid sub string.
                        let invalidToken = new NightingaleCompiler.LexicalToken(INVALID_TOKEN, null, currentChunk, this.lineNumber, lastPosition);
                        // Emit invalid token
                        this.tokenStream.push(this.tempToken);
                        this.stacktraceStack.push(this.tempToken);
                        console.log(`Stream-Token: ${invalidToken.name}, Ancestor: ${invalidToken.ancestor}, Line-Position: ${invalidToken.linePosition}`);
                        // Move last position up one line position
                        lastPosition++;
                        currentPosition = lastPosition + 1;
                    } // else
                } // else-if
                // Not in comment nor in a string
                else {
                    // Keeps track if the current substring matches a token definition from the token pool.
                    let matchFound = false;
                    // Symbols, whitespace (if present and outside of quotes) and the EOP 
                    // meta-symbol mean that we can stop moving ahead and see what we’ve got so far.
                    if (/=$|\{$|\}$|\($|\)$|\"$|\+$|\/\*$|\\*\/$|\s$|\$$/.test(currentChunk) && currentChunk.length > 1) {
                        /*
                         * Tokens were found in the substring.
                         *
                         * Temporary token is useful:
                         *      - If null, no tokens were found.
                         *      - If not null, stores the longest matched token.
                        */
                        if (this.tempToken != null) {
                            // Emit the longest matched token.
                            this.tokenStream.push(this.tempToken);
                            this.stacktraceStack.push(this.tempToken);
                            console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);
                            // Move the starting position after the string value that created the token.
                            lastPosition += this.tempToken.ancestor.length;
                            // Reset the current position back to the new starting position
                            currentPosition = lastPosition + 1;
                            // Reset temp token
                            this.tempToken = null;
                            // Skip the Check Tokens From Token Pool Loop
                            continue LoopThroughSourceCodeWhileLoop;
                        } // if
                        /*
                         * No tokens were found in the substring.
                         *
                         * That means the entire substring is filled with invalid
                         * tokens, except for the last character which must be a symbol.
                        */
                        else {
                            // Generate an invalid token for the first character in the invalid sub string.
                            let invalidToken = new NightingaleCompiler.LexicalToken(INVALID_TOKEN, null, currentChunk[0], this.lineNumber, lastPosition);
                            // Emit invalid token
                            this.tokenStream.push(this.tempToken);
                            this.stacktraceStack.push(this.tempToken);
                            console.log(`Stream-Token: ${invalidToken.name}, Ancestor: ${invalidToken.ancestor}, Line-Position: ${invalidToken.linePosition}`);
                            // Move last position up one line position
                            lastPosition++;
                            currentPosition = lastPosition + 1;
                            // Skip the Check Tokens From Token Pool Loop
                            continue LoopThroughSourceCodeWhileLoop;
                        } // else
                    } // if
                    // Test current substring of source code against tokens in the token pool
                    CheckTokensFromTokenPoolLoop: for (let indexOfToken = 0; indexOfToken < tokenPool.length; ++indexOfToken) {
                        let currentToken = tokenPool[indexOfToken];
                        // Test against specific token
                        /**
                         * Test against a token from token pool.
                         *
                         * Some Special Cases:
                         *  1.) Qoute
                         *      - All characters in a quote are CHARACTER_TOKENS
                         *  2.) Keywords
                         *      - true | false | while | if | print | int | boolean | string
                         *  3.) Overlapping Symbols
                         *      - BoolOpEquals (==) and Assignment OP (=) have overlaping sets, in this case =.
                         *  4.) Whitespace
                         *  5.) End of program
                         */
                        if (currentToken.definition.test(currentChunk)) {
                            matchFound = true;
                            // String expression boundary symbol found, could be start or end.
                            if (currentToken.name == STRING_EXPRESSION_BOUNDARY) {
                                // Start of string
                                if (!this.isInString) {
                                    this.isInString = true;
                                    // Keep track where the string started
                                    this.startStringExpressionLine = this.lineNumber;
                                    this.startStringExpressionPosition = this.linePosition;
                                    // Generate STRING_EXPRESSION_BOUNDARY token.
                                    this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition);
                                    // Emit 
                                    this.tokenStream.push(this.tempToken);
                                    this.stacktraceStack.push(this.tempToken);
                                    console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${currentPosition}`);
                                } // if
                                // End of string
                                else {
                                    this.isInString = false;
                                } // else
                                // Increase the current position, whether a match was found or not.
                                lastPosition = currentPosition;
                                currentPosition = lastPosition + 1;
                                continue LoopThroughSourceCodeWhileLoop;
                            } // if
                            // Symbol found
                            else if (currentToken.name.includes(SYMBOL)) {
                                /**
                                 * Keeps track if a longer symbol is found or not.
                                 *
                                 * If a longer symbol is found, the starting position must be
                                 * moved after the longer symbol, instead of the shorted symbol.
                                 */
                                let longerSymbolFound = false;
                                /**
                                 * Save the current symbols token.
                                 *
                                 * If a longer symbol is found by peeking ahead, this symbols token
                                 * will be replaced with a new token for the longer symbol that was found.
                                 */
                                this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition);
                                /**
                                 * Peek ahead one line-position.
                                 *
                                 * Some symbols have overlapping sets, such as:
                                 *  - Assignment Operation (=) and Boolean Operation Equals (==).
                                 *  - Boolean Operation Not Equals (!=) and Boolean Operation Equals (==).
                                 *
                                 * Therfore, we must peek ahead to check for the LONGEST symbol.
                                 * Since our current language's longest symbols are length 2, we only need to peek ahead one line-position.
                                 */
                                let peekPosition = currentPosition + 1;
                                // Only peek ahead if we do not fall off the string (or in some languages, wrap-around).
                                if (peekPosition <= sourceCode.length) {
                                    /**
                                     * Generate a new substring from peeking ahead a line-position.
                                     *
                                     * The longer substring will be tested to see if it matches a longer token.
                                     * If so, replace the original symbol token, with the current longer symbol token.
                                     */
                                    let peekingChunk = sourceCode.substring(lastPosition, peekPosition);
                                    // Loop through pool of tokens to see if the longer substring matches any of definitions.
                                    CheckForLongerSymbolLoop: for (let index = 0; index < tokenPool.length; ++index) {
                                        // Longer symbol has a token match!
                                        if (tokenPool[index].definition.test(peekingChunk)) {
                                            // Notify through boolean that the starting 
                                            // position must be changed to after the new LONGER symbol.
                                            longerSymbolFound = true;
                                            // Replace the current symbol token with the new longer token.
                                            this.tempToken = tokenPool[index].copyWith(peekingChunk, this.lineNumber, peekPosition);
                                            /**
                                             * Break out of loop on first token match.
                                             *
                                             * This enforces priority of tokens by the order they are listed in the pool.
                                             */
                                            break CheckForLongerSymbolLoop;
                                        } // if
                                    } // for
                                } // if
                                // Longer symbol found
                                if (longerSymbolFound) {
                                    // Mover last position after the longer symbol.
                                    lastPosition = peekPosition;
                                    // Reset the current position to new starting point.
                                    currentPosition = lastPosition + 1;
                                } // if
                                // No longer token found.
                                else {
                                    // Move the starting position after the string value that created the token.
                                    lastPosition += this.tempToken.ancestor.length;
                                    // Reset the current position back to the new starting position.
                                    currentPosition = lastPosition + 1;
                                } // else
                                // Emit token to stream.
                                this.tokenStream.push(this.tempToken);
                                this.stacktraceStack.push(this.tempToken);
                                console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);
                                continue LoopThroughSourceCodeWhileLoop;
                            } // else-if
                            // Special Case: End Of Program Meta Symbol
                            else if (currentToken.name.includes(END_OF_PROGRAM)) {
                                // Generate end of program token.
                                this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition);
                                // Emit final token
                                console.log(`EOP-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${currentPosition}`);
                                /**
                                 * Reset some variables in the lexer to allow for another program to be read.
                                 *
                                 * Probably don't want to reset the line number or anything.
                                 * But make sure you are starting fresh enough for a new program...
                                 *
                                 * Also make sure to update the last and current positions to start after the EOP ($) symbol
                                 */
                                lastPosition = currentPosition;
                                currentPosition = lastPosition + 1;
                                continue LoopThroughSourceCodeWhileLoop;
                            } // else-if
                            // Normal Case Token
                            else {
                                // Replace temporary token with the new longest token.
                                this.tempToken = currentToken.copyWith(currentChunk, this.lineNumber, currentPosition - (currentChunk.length - 1));
                                /**
                                 * Intermediate Token shown in stacktrace.
                                 *
                                 * This is the first possible token found.
                                 * Most likely will be overriden if a longer token match is found.
                                 */
                                // console.log(`StackTrace-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);
                                // Increase the current position, whether a match was found or not.
                                currentPosition++;
                                continue LoopThroughSourceCodeWhileLoop;
                            } // else
                        } // if 
                    } // for
                    /**
                     * Characters that are not matched are illegal.
                     *
                     * Some tokens have sets that overlap with illegal characters.
                     *  - BOOLEAN NOT EQUALS OPERATION (!=) overlaps with illegal character (!).
                     *  - START BLOCK COMMENT (/ *) overlaps with illegal character (/).
                     *  - END BLOCK COMMENT (* /), overlaps with illegal character (*).
                     */
                    if (!matchFound) {
                        /**
                         * Check for the 3 illegal characters: ! or / or *
                         *
                         * Must peek ahead to see if those illegal characters
                         * are followed by a character that would make them legal symbols.
                         *
                         * For example:
                         *      - ! is illegal, but if followed by an = symbol,
                         *        becomes a legal != Boolean Operation Not Equal.
                         *      - / is illegal, but if folowed by an *, becomes a legal Start Comment Symbol.
                         */
                        if (/(^!$|^\*$|^\/$)/.test(currentChunk)) {
                            /**
                             * Peek ahead one position.
                             *
                             * Only need to peek ahead one position since
                             * SYMBOLS in our grammar are only a max length of 2.
                             */
                            let nextPosition = currentPosition + 1;
                            let peekingChunk = sourceCode.substring(lastPosition, nextPosition);
                            /**
                             * Validate the new substring against the pool of tokens.
                             *
                             * For example:
                             *  - 1.) Original illegal symbol was !.
                             *  - 2.) We peeked ahead another character so now our new substring is !=.
                             *  - 3.) NOW, we validate != against the token pool.
                             */
                            for (let index = 0; index < tokenPool.length; ++index) {
                                // New substring matches a token!
                                if (tokenPool[index].definition.test(peekingChunk)) {
                                    // Generate a new token.
                                    this.tempToken = tokenPool[index].copyWith(peekingChunk, this.lineNumber, nextPosition);
                                    // Special Case: token match was a START_BLOCK_COMMENT
                                    if (this.tempToken.name == START_BLOCK_COMMENT) {
                                        this.isInComment = true;
                                        // Keep track of the location
                                        this.startCommentLine = this.lineNumber;
                                        this.startCommentLinePosition = currentPosition;
                                    } // if: START_BLOCK_COMMENT
                                    // Special Case: token match was END_BLOCK_COMMENT
                                    if (this.tempToken.name == END_BLOCK_COMMENT) {
                                        // End Block Comment Symbol found without a matching Start Block Comment Symbol.
                                        if (!this.isInComment) {
                                            // Throw error
                                            continue LoopThroughSourceCodeWhileLoop;
                                        } // if: mismatch error
                                        // End Block Comment Symbol has matching Start Block Comment Symbol.
                                        else {
                                            this.isInComment = false;
                                            // Keep track of the location
                                            this.endCommentLine = this.lineNumber;
                                            this.endCommentLinePosition = currentPosition;
                                        } // else: no error
                                    } // if: END_BLOCK_COMMENT
                                    // Emit Token
                                    this.tokenStream.push(this.tempToken);
                                    this.stacktraceStack.push(this.tempToken);
                                    console.log(`Stream-Token: ${this.tempToken.name}, Ancestor: ${this.tempToken.ancestor}, Line-Position: ${this.tempToken.linePosition}`);
                                    // Update position
                                    lastPosition = nextPosition;
                                    currentPosition = lastPosition + 1;
                                    continue LoopThroughSourceCodeWhileLoop;
                                } // if: token match
                            } // for: validate against token pool
                        } // if: illegal character is: ! or / or *
                        // Not a special illegal character.
                        else {
                            currentPosition++;
                        } // else: not an illegal: ! or / or *
                    } // if: no token match found
                } // else: not in comment nor in string
            } // while: loop through source code
        } // function: main
    } // class: lexer
    NightingaleCompiler.Lexer = Lexer;
})(NightingaleCompiler || (NightingaleCompiler = {})); // module: NightingaleCompiler
//  /=$|\{$|\}$|\($|\)$|\!$|\"$|\+$|\/\*$|\\*\/$|\s$/
//# sourceMappingURL=lexer.js.map